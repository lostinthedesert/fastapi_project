We're looking at the 'JOIN' function of SQL. This will allow us to joing two tables based on shared column values. So for example 'posts' has a column called 'owner_id' that is a foreign key corresponding to 'users.id'. So those two column values will always match each other. If we want to create a table that combines these two tables and sorts them by their shared column values, we use the JOIN function. This would come in handy if we wanted to create a get request that showed how many posts a user had or listed all posts by username(email) or if we wanted to show how many likes a post has.

The syntax is very simple and I have bookmarked the postgres sql tutorial on JOIN. Here are some examples from our databases:

'select * from posts left join users on posts.owner_id=users.id'

In this example we have selected all columns (from two tables) starting with 'posts' (left table) and 'LEFT JOIN'ed it with 'users' (right table) where posts.owner_id is equal to users.id. This will give us a table where the 'posts' table now has all the columns from the 'users' table appended onto its right side where the post.owner_id equals users.id. In this way 'posts' is like our primary table. It is the starting reference for all manipulation that follows. Meaning that 'users' will be appended to it (not the other way around) and the original order of our 'posts' table will remain the same while 'users' will be organized to meet the criteria of our 'LEFT JOIN' command. We can reverse that by using RIGHT JOIN, making the second table referenced in the above code the primary table from which the results will be organized. But we'll focus on LEFT JOIN for now.

After that, we can sort the results as we wish. So say we don't want to mash the tables together with all the columns shown. If we do this:

select email, title, content from posts left join users on posts.owner_id=users.id

that will give us a neat JOINed table where only the email, title and content columns appear. Note that if you are selecting a column that exists in both tables (for example 'id' exists in users and posts) you must use the syntax 'SELECT posts.id etc.' to specify which column by that value you are selecting from which table.

If we want to count how many posts a user has we can join the tables and have sql count how many times a post with owner_id x occurs. Like this:

SELECT users.id, COUNT(*) FROM posts LEFT JOIN users on posts.owner_id=users.id GROUP BY users.id;

This will return a table with two columns: user.id and 'count' and two rows (we only have two users) that will show us how many posts each user id has. The only issue here is that this won't return a result for any user who doesn't have a post. So in order to do that we have to change which table is the primary so that the user is the frame of reference for our query. So we change LEFT JOIN to RIGHT JOIN. And then to avoid a common error in the COUNT() function, instead of calling COUNT all we need to specify what column to count so let's do 'COUNT(posts.id)'. that way sql will count how many post ids each user has and tell us if any users have 0.

SELECT users.id, COUNT(posts.id) FROM posts RIGHT JOIN users on posts.owner_id=users.id GROUP BY users.id;

Here is our vote counting sql code:

select posts.id, COUNT(post_id) as votes from posts left join votes on posts.id=post_id
group by posts.id

Note how we changed the name of the COUNT() column to 'votes' with the 'AS' function. And if we wanted to find out how many votes an individual post has we simply add a 'WHERE' statement:

select posts.id, COUNT(post_id) as votes from posts left join votes on posts.id=post_id
where posts.id=10 group by posts.id

And lastly if we want to include all columns from only the posts table we change the select variable to posts.*

select posts.*, COUNT(post_id) as votes from posts left join votes on posts.id=post_id
where posts.id=10 group by posts.id